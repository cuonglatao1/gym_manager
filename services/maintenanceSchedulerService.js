const { MaintenanceSchedule, Equipment, EquipmentMaintenance, MaintenanceHistory, User } = require('../models');
const { Op } = require('sequelize');

class MaintenanceSchedulerService {
    constructor() {
        this.priorityRules = {
            high: {
                cleaning: { interval: 1, priority: 'high' },      // Daily cleaning
                inspection: { interval: 7, priority: 'high' },    // Weekly inspection
                maintenance: { interval: 30, priority: 'medium' }  // Monthly maintenance
            },
            medium: {
                cleaning: { interval: 3, priority: 'medium' },    // Every 3 days cleaning
                inspection: { interval: 14, priority: 'medium' }, // Bi-weekly inspection
                maintenance: { interval: 60, priority: 'medium' } // Every 2 months maintenance
            },
            low: {
                cleaning: { interval: 7, priority: 'low' },       // Weekly cleaning
                inspection: { interval: 30, priority: 'low' },    // Monthly inspection
                maintenance: { interval: 90, priority: 'low' }    // Every 3 months maintenance
            }
        };
    }

    /**
     * Create automatic maintenance schedules for new equipment
     */
    async createSchedulesForEquipment(equipmentId, priority = 'medium', startDate = null) {
        try {
            const equipment = await Equipment.findByPk(equipmentId);
            if (!equipment) {
                throw new Error('Equipment not found');
            }

            const baseDate = startDate ? new Date(startDate) : new Date();
            const rules = this.priorityRules[priority];
            
            if (!rules) {
                throw new Error(`Invalid priority level: ${priority}`);
            }

            const schedules = [];
            
            for (const [maintenanceType, rule] of Object.entries(rules)) {
                const nextDueDate = new Date(baseDate);
                nextDueDate.setDate(nextDueDate.getDate() + rule.interval);
                
                const schedule = await MaintenanceSchedule.create({
                    equipmentId,
                    maintenanceType,
                    priority,
                    intervalDays: rule.interval,
                    nextDueDate: nextDueDate.toISOString().split('T')[0],
                    autoGenerated: true,
                    notes: `Auto-generated ${maintenanceType} schedule for ${priority} priority equipment`
                });
                
                schedules.push(schedule);
            }

            console.log(`✅ Created ${schedules.length} maintenance schedules for equipment ${equipment.name}`);
            return schedules;
        } catch (error) {
            console.error('Error creating schedules for equipment:', error);
            throw error;
        }
    }

    /**
     * Update schedules when equipment priority changes
     */
    async updateSchedulesForPriorityChange(equipmentId, newPriority) {
        try {
            const equipment = await Equipment.findByPk(equipmentId);
            if (!equipment) {
                throw new Error('Equipment not found');
            }

            // Deactivate existing auto-generated schedules
            await MaintenanceSchedule.update(
                { isActive: false },
                { 
                    where: { 
                        equipmentId, 
                        autoGenerated: true 
                    } 
                }
            );

            // Create new schedules with updated priority
            const newSchedules = await this.createSchedulesForEquipment(
                equipmentId, 
                newPriority, 
                equipment.lastMaintenanceDate || equipment.purchaseDate
            );

            console.log(`✅ Updated schedules for equipment ${equipment.name} with new priority: ${newPriority}`);
            return newSchedules;
        } catch (error) {
            console.error('Error updating schedules for priority change:', error);
            throw error;
        }
    }

    /**
     * Generate maintenance tasks for overdue schedules
     */
    async generateOverdueTasks(assignedTo = null, maxTasks = 50) {
        try {
            const today = new Date().toISOString().split('T')[0];
            
            const overdueSchedules = await MaintenanceSchedule.findAll({
                where: {
                    nextDueDate: { [Op.lt]: today },
                    isActive: true
                },
                include: [{
                    model: Equipment,
                    as: 'equipment',
                    where: { status: 'active' }
                }],
                order: [
                    ['nextDueDate', 'ASC'],
                    [{ model: Equipment, as: 'equipment' }, 'priority', 'DESC']
                ],
                limit: maxTasks
            });

            const tasks = [];
            for (const schedule of overdueSchedules) {
                try {
                    // Check if task already exists
                    const existingTask = await EquipmentMaintenance.findOne({
                        where: {
                            equipmentId: schedule.equipmentId,
                            maintenanceType: this.mapMaintenanceType(schedule.maintenanceType),
                            scheduledDate: schedule.nextDueDate,
                            status: { [Op.in]: ['scheduled', 'in_progress'] }
                        }
                    });

                    if (!existingTask) {
                        const task = await this.createMaintenanceTask(schedule, assignedTo);
                        tasks.push(task);
                    }
                } catch (error) {
                    console.error(`Error generating task for schedule ${schedule.id}:`, error);
                }
            }

            console.log(`✅ Generated ${tasks.length} maintenance tasks from overdue schedules`);
            return tasks;
        } catch (error) {
            console.error('Error generating overdue tasks:', error);
            throw error;
        }
    }

    /**
     * Generate upcoming maintenance tasks (next 7 days)
     */
    async generateUpcomingTasks(days = 7, assignedTo = null) {
        try {
            const today = new Date();
            const futureDate = new Date();
            futureDate.setDate(today.getDate() + days);
            
            const upcomingSchedules = await MaintenanceSchedule.findAll({
                where: {
                    nextDueDate: {
                        [Op.between]: [
                            today.toISOString().split('T')[0],
                            futureDate.toISOString().split('T')[0]
                        ]
                    },
                    isActive: true
                },
                include: [{
                    model: Equipment,
                    as: 'equipment',
                    where: { status: 'active' }
                }],
                order: [
                    ['nextDueDate', 'ASC'],
                    [{ model: Equipment, as: 'equipment' }, 'priority', 'DESC']
                ]
            });

            const tasks = [];
            for (const schedule of upcomingSchedules) {
                try {
                    // Check if task already exists
                    const existingTask = await EquipmentMaintenance.findOne({
                        where: {
                            equipmentId: schedule.equipmentId,
                            maintenanceType: this.mapMaintenanceType(schedule.maintenanceType),
                            scheduledDate: schedule.nextDueDate,
                            status: { [Op.in]: ['scheduled', 'in_progress'] }
                        }
                    });

                    if (!existingTask) {
                        const task = await this.createMaintenanceTask(schedule, assignedTo);
                        tasks.push(task);
                    }
                } catch (error) {
                    console.error(`Error generating upcoming task for schedule ${schedule.id}:`, error);
                }
            }

            console.log(`✅ Generated ${tasks.length} upcoming maintenance tasks`);
            return tasks;
        } catch (error) {
            console.error('Error generating upcoming tasks:', error);
            throw error;
        }
    }

    /**
     * Complete maintenance and update schedule
     */
    async completeMaintenance(maintenanceId, performedBy, workDetails = {}) {
        try {
            const maintenance = await EquipmentMaintenance.findByPk(maintenanceId, {
                include: [{
                    model: Equipment,
                    as: 'equipment'
                }]
            });

            if (!maintenance) {
                throw new Error('Maintenance record not found');
            }

            // Mark maintenance as completed
            await maintenance.update({
                status: 'completed',
                completedDate: new Date().toISOString().split('T')[0],
                workPerformed: workDetails.workPerformed || 'Maintenance completed',
                actualDuration: workDetails.duration,
                cost: workDetails.cost || 0
            });

            // Create maintenance history record
            const historyRecord = await MaintenanceHistory.create({
                equipmentId: maintenance.equipmentId,
                maintenanceId: maintenance.id,
                maintenanceType: maintenance.maintenanceType,
                performedDate: new Date().toISOString().split('T')[0],
                performedBy,
                duration: workDetails.duration,
                workPerformed: workDetails.workPerformed || 'Maintenance completed',
                issuesFound: workDetails.issuesFound,
                partsReplaced: workDetails.partsReplaced,
                cost: workDetails.cost || 0,
                equipmentConditionBefore: workDetails.conditionBefore || 'good',
                equipmentConditionAfter: workDetails.conditionAfter || 'good',
                priority: maintenance.priority,
                result: 'completed',
                qualityRating: workDetails.qualityRating,
                notes: workDetails.notes
            });

            // Update related schedule
            const schedule = await MaintenanceSchedule.findOne({
                where: {
                    equipmentId: maintenance.equipmentId,
                    maintenanceType: this.mapScheduleMaintenanceType(maintenance.maintenanceType),
                    isActive: true
                }
            });

            if (schedule) {
                await schedule.completeAndReschedule();
            }

            // Update equipment's last maintenance date
            await maintenance.equipment.update({
                lastMaintenanceDate: new Date().toISOString().split('T')[0],
                status: 'active' // Ensure equipment is active after maintenance
            });

            console.log(`✅ Completed maintenance ${maintenanceId} and updated schedule`);
            return { maintenance, historyRecord, schedule };
        } catch (error) {
            console.error('Error completing maintenance:', error);
            throw error;
        }
    }

    /**
     * Get maintenance dashboard data
     */
    async getMaintenanceDashboard() {
        try {
            const today = new Date().toISOString().split('T')[0];
            
            // Get overdue maintenance count
            const overdueCount = await MaintenanceSchedule.count({
                where: {
                    nextDueDate: { [Op.lt]: today },
                    isActive: true
                }
            });

            // Get today's maintenance
            const todayCount = await MaintenanceSchedule.count({
                where: {
                    nextDueDate: today,
                    isActive: true
                }
            });

            // Get this week's maintenance
            const weekEnd = new Date();
            weekEnd.setDate(weekEnd.getDate() + 7);
            const thisWeekCount = await MaintenanceSchedule.count({
                where: {
                    nextDueDate: {
                        [Op.between]: [today, weekEnd.toISOString().split('T')[0]]
                    },
                    isActive: true
                }
            });

            // Get active maintenance tasks
            const activeTasks = await EquipmentMaintenance.count({
                where: {
                    status: { [Op.in]: ['scheduled', 'in_progress'] }
                }
            });

            // Get equipment by priority
            const equipmentByPriority = await Equipment.findAll({
                attributes: [
                    'priority',
                    [Equipment.sequelize.fn('COUNT', Equipment.sequelize.col('id')), 'count']
                ],
                where: { isActive: true },
                group: ['priority'],
                raw: true
            });

            // Get recent completed maintenance
            const recentMaintenance = await MaintenanceHistory.findAll({
                limit: 5,
                order: [['performedDate', 'DESC']],
                include: [
                    {
                        model: Equipment,
                        as: 'equipment',
                        attributes: ['name', 'equipmentCode']
                    },
                    {
                        model: User,
                        as: 'performer',
                        attributes: ['fullName', 'username']
                    }
                ]
            });

            return {
                summary: {
                    overdueCount,
                    todayCount,
                    thisWeekCount,
                    activeTasks
                },
                equipmentByPriority: equipmentByPriority.reduce((acc, item) => {
                    acc[item.priority] = parseInt(item.count);
                    return acc;
                }, {}),
                recentMaintenance
            };
        } catch (error) {
            console.error('Error getting maintenance dashboard:', error);
            throw error;
        }
    }

    /**
     * Auto-assign maintenance tasks based on staff availability
     */
    async autoAssignTasks(taskIds = null) {
        try {
            let tasks;
            
            if (taskIds && taskIds.length > 0) {
                tasks = await EquipmentMaintenance.findAll({
                    where: {
                        id: { [Op.in]: taskIds },
                        status: 'scheduled',
                        assignedTo: null
                    }
                });
            } else {
                tasks = await EquipmentMaintenance.findAll({
                    where: {
                        status: 'scheduled',
                        assignedTo: null,
                        scheduledDate: {
                            [Op.lte]: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // Next 7 days
                        }
                    },
                    order: [['scheduledDate', 'ASC'], ['priority', 'DESC']]
                });
            }

            // Get available staff (users with role 'staff' or 'admin')
            const availableStaff = await User.findAll({
                where: {
                    role: { [Op.in]: ['staff', 'admin'] },
                    isActive: true
                },
                attributes: ['id', 'fullName', 'username']
            });

            if (availableStaff.length === 0) {
                throw new Error('No available staff for task assignment');
            }

            const assignedTasks = [];
            let staffIndex = 0;

            for (const task of tasks) {
                try {
                    const assignedStaff = availableStaff[staffIndex % availableStaff.length];
                    
                    await task.update({
                        assignedTo: assignedStaff.id
                    });

                    assignedTasks.push({
                        taskId: task.id,
                        assignedTo: assignedStaff.id,
                        assignedToName: assignedStaff.fullName || assignedStaff.username
                    });

                    staffIndex++;
                } catch (error) {
                    console.error(`Error assigning task ${task.id}:`, error);
                }
            }

            console.log(`✅ Auto-assigned ${assignedTasks.length} maintenance tasks`);
            return assignedTasks;
        } catch (error) {
            console.error('Error auto-assigning tasks:', error);
            throw error;
        }
    }

    /**
     * Helper method to create maintenance task from schedule
     */
    async createMaintenanceTask(schedule, assignedTo = null) {
        const task = await EquipmentMaintenance.create({
            equipmentId: schedule.equipmentId,
            maintenanceType: this.mapMaintenanceType(schedule.maintenanceType),
            status: 'scheduled',
            priority: this.mapTaskPriority(schedule.priority),
            scheduledDate: schedule.nextDueDate,
            assignedTo,
            title: this.generateTaskTitle(schedule),
            description: this.generateTaskDescription(schedule),
            isRecurring: true,
            recurringInterval: schedule.intervalDays
        });

        return task;
    }

    /**
     * Map schedule maintenance type to task maintenance type
     */
    mapMaintenanceType(scheduleType) {
        const mapping = {
            'cleaning': 'daily_clean',
            'inspection': 'weekly_check',
            'maintenance': 'monthly_maintenance'
        };
        return mapping[scheduleType] || 'daily_clean';
    }

    /**
     * Map task maintenance type to schedule maintenance type
     */
    mapScheduleMaintenanceType(taskType) {
        const mapping = {
            'daily_clean': 'cleaning',
            'weekly_check': 'inspection',
            'monthly_maintenance': 'maintenance'
        };
        return mapping[taskType] || 'cleaning';
    }

    /**
     * Map schedule priority to task priority
     */
    mapTaskPriority(schedulePriority) {
        const mapping = {
            'high': 'high',
            'medium': 'medium',
            'low': 'low'
        };
        return mapping[schedulePriority] || 'medium';
    }

    /**
     * Generate task title
     */
    generateTaskTitle(schedule) {
        const typeNames = {
            'cleaning': 'Vệ sinh thiết bị',
            'inspection': 'Kiểm tra thiết bị',
            'maintenance': 'Bảo dưỡng thiết bị'
        };
        return `${typeNames[schedule.maintenanceType]} (Tự động)`;
    }

    /**
     * Generate task description
     */
    generateTaskDescription(schedule) {
        const descriptions = {
            'cleaning': 'Vệ sinh và làm sạch thiết bị theo quy trình tiêu chuẩn',
            'inspection': 'Kiểm tra tình trạng hoạt động và an toàn của thiết bị',
            'maintenance': 'Bảo dưỡng, kiểm tra chi tiết và thay thế linh kiện nếu cần'
        };
        
        const priorityNotes = {
            'high': 'Ưu tiên cao - Cần thực hiện ngay',
            'medium': 'Ưu tiên trung bình - Thực hiện theo lịch',
            'low': 'Ưu tiên thấp - Có thể linh hoạt thời gian'
        };
        
        return `${descriptions[schedule.maintenanceType]}.\n\nMức độ ưu tiên: ${priorityNotes[schedule.priority]}\nKhoảng cách: ${schedule.intervalDays} ngày`;
    }
}

module.exports = new MaintenanceSchedulerService();